{
  "version": 3,
  "sources": ["../../@brillout/json-serializer/dist/utils/isReactElement.js", "../../@brillout/json-serializer/dist/utils/isCallable.js", "../../@brillout/json-serializer/dist/utils/isObject.js", "../../@brillout/json-serializer/dist/utils/addPathToReplacer.js", "../../@brillout/json-serializer/dist/stringify.js"],
  "sourcesContent": ["export function isReactElement(value) {\n    return (typeof value === 'object' &&\n        value !== null &&\n        String(value['$$typeof']) === 'Symbol(react.element)');\n}\n", "export function isCallable(thing) {\n    return thing instanceof Function || typeof thing === 'function';\n}\n", "export { isObject };\nfunction isObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    if (Array.isArray(value)) {\n        return false;\n    }\n    return true;\n}\n", "export { addPathToReplacer };\n/**\n * The `replacer()` callback of `JSON.stringify()` doesn't provide the path of the object property that is being stringified.\n *\n * `addPathToReplacer(replacer)` adds the property path to the `replacer()` callback as last parameter.\n */\nfunction addPathToReplacer(replacer) {\n    const pathMap = new WeakMap();\n    return replacerForJsonStringify;\n    function replacerForJsonStringify(key, valueAfterNativeJsonStringify) {\n        const pathPrevious = pathMap.get(this) ?? [];\n        const path = [...pathPrevious];\n        if (key !== '') {\n            const pathEntry = !Array.isArray(this) ? key : parseInt(key, 10);\n            path.push(pathEntry);\n        }\n        if (isIterable(valueAfterNativeJsonStringify))\n            pathMap.set(valueAfterNativeJsonStringify, path);\n        return replacer.call(this, key, valueAfterNativeJsonStringify, path);\n    }\n}\nfunction isIterable(value) {\n    return value === Object(value);\n}\n", "export { stringify };\nexport { isJsonSerializerError };\nimport { types } from './types.js';\nimport { isReactElement } from './utils/isReactElement.js';\nimport { isCallable } from './utils/isCallable.js';\nimport { isObject } from './utils/isObject.js';\nimport { addPathToReplacer } from './utils/addPathToReplacer.js';\nfunction stringify(value, { forbidReactElements, space, valueName, sortObjectKeys, replacer: replacerUserProvided, } = {}) {\n    // The only error `JSON.stringify()` can throw is `TypeError \"cyclic object value\"`.\n    // - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#exceptions\n    // - This means we have total of 3 possible errors while serializing:\n    //    - Cyclic references\n    //    - Functions\n    //    - React elements\n    const serializer = (val) => JSON.stringify(val, addPathToReplacer(replacer), space);\n    return serializer(value);\n    function replacer(key, _valueAfterNativeJsonStringify, path) {\n        const valueOriginal = this[key];\n        let value = valueOriginal;\n        {\n            const ret = replacerUserProvided?.call(this, key, valueOriginal, serializer);\n            if (ret) {\n                value = ret.replacement;\n                if (ret.resolved !== false)\n                    return value;\n            }\n        }\n        if (forbidReactElements && isReactElement(value)) {\n            throw genErr({\n                value,\n                valueType: 'React element',\n                path,\n                rootValueName: valueName,\n            });\n        }\n        if (isCallable(value)) {\n            const functionName = value.name;\n            throw genErr({\n                value,\n                valueType: 'function',\n                path,\n                rootValueName: valueName,\n                problematicValueName: path.length === 0 ? functionName : undefined,\n            });\n        }\n        for (const { is, serialize } of types.slice().reverse()) {\n            if (is(value)) {\n                //@ts-ignore\n                return serialize(value, serializer);\n            }\n        }\n        if (sortObjectKeys && isObject(value)) {\n            const copy = {};\n            Object.keys(value)\n                .sort()\n                .forEach((key) => {\n                copy[key] = value[key];\n            });\n            value = copy;\n        }\n        return value;\n    }\n}\nfunction genErr({ value, valueType, path, rootValueName, problematicValueName, }) {\n    const subjectName = getSubjectName({ path, rootValueName, problematicValueName });\n    const messageCore = `cannot serialize ${subjectName} because it's a ${valueType}`;\n    const err = new Error(`[@brillout/json-serializer](https://github.com/brillout/json-serializer) ${messageCore}.`);\n    const pathString = getPathString(path, true);\n    const errAddendum = {\n        [stamp]: true,\n        messageCore,\n        value,\n        path,\n        pathString,\n        subjectName,\n    };\n    Object.assign(err, errAddendum);\n    return err;\n}\nconst stamp = '_isJsonSerializerError';\nfunction isJsonSerializerError(thing) {\n    return isObject(thing) && thing[stamp] === true;\n}\nfunction getSubjectName({ path, rootValueName, problematicValueName, }) {\n    const pathString = getPathString(path, !rootValueName);\n    let subjectName;\n    if (!pathString) {\n        subjectName = rootValueName || problematicValueName || 'value';\n    }\n    else {\n        if (problematicValueName) {\n            subjectName = problematicValueName + ' at ';\n        }\n        else {\n            subjectName = '';\n        }\n        subjectName = subjectName + (rootValueName || '') + pathString;\n    }\n    return subjectName;\n}\nfunction getPathString(path, canBeFirstKey) {\n    const pathString = path\n        .map((key, i) => {\n        if (typeof key === 'number') {\n            return `[${key}]`;\n        }\n        if (i === 0 && canBeFirstKey && isKeyDotNotationCompatible(key)) {\n            return key;\n        }\n        return getPropAccessNotation(key);\n    })\n        .join('');\n    return pathString;\n}\nfunction getPropAccessNotation(key) {\n    return typeof key === 'string' && isKeyDotNotationCompatible(key) ? `.${key}` : `[${JSON.stringify(key)}]`;\n}\nfunction isKeyDotNotationCompatible(key) {\n    return /^[a-z0-9\\$_]+$/i.test(key);\n}\n"],
  "mappings": "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",
  "names": ["value", "key"]
}
