import {
  types
} from "./chunk-OT4DE2KZ.js";
import "./chunk-DC5AMYBS.js";

// node_modules/@brillout/json-serializer/dist/utils/isReactElement.js
function isReactElement(value) {
  return typeof value === "object" && value !== null && String(value["$$typeof"]) === "Symbol(react.element)";
}

// node_modules/@brillout/json-serializer/dist/utils/isCallable.js
function isCallable(thing) {
  return thing instanceof Function || typeof thing === "function";
}

// node_modules/@brillout/json-serializer/dist/utils/isObject.js
function isObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (Array.isArray(value)) {
    return false;
  }
  return true;
}

// node_modules/@brillout/json-serializer/dist/utils/addPathToReplacer.js
function addPathToReplacer(replacer) {
  const pathMap = /* @__PURE__ */ new WeakMap();
  return replacerForJsonStringify;
  function replacerForJsonStringify(key, valueAfterNativeJsonStringify) {
    const pathPrevious = pathMap.get(this) ?? [];
    const path = [...pathPrevious];
    if (key !== "") {
      const pathEntry = !Array.isArray(this) ? key : parseInt(key, 10);
      path.push(pathEntry);
    }
    if (isIterable(valueAfterNativeJsonStringify))
      pathMap.set(valueAfterNativeJsonStringify, path);
    return replacer.call(this, key, valueAfterNativeJsonStringify, path);
  }
}
function isIterable(value) {
  return value === Object(value);
}

// node_modules/@brillout/json-serializer/dist/stringify.js
function stringify(value, { forbidReactElements, space, valueName, sortObjectKeys, replacer: replacerUserProvided } = {}) {
  const serializer = (val) => JSON.stringify(val, addPathToReplacer(replacer), space);
  return serializer(value);
  function replacer(key, _valueAfterNativeJsonStringify, path) {
    const valueOriginal = this[key];
    let value2 = valueOriginal;
    {
      const ret = replacerUserProvided == null ? void 0 : replacerUserProvided.call(this, key, valueOriginal, serializer);
      if (ret) {
        value2 = ret.replacement;
        if (ret.resolved !== false)
          return value2;
      }
    }
    if (forbidReactElements && isReactElement(value2)) {
      throw genErr({
        value: value2,
        valueType: "React element",
        path,
        rootValueName: valueName
      });
    }
    if (isCallable(value2)) {
      const functionName = value2.name;
      throw genErr({
        value: value2,
        valueType: "function",
        path,
        rootValueName: valueName,
        problematicValueName: path.length === 0 ? functionName : void 0
      });
    }
    for (const { is, serialize } of types.slice().reverse()) {
      if (is(value2)) {
        return serialize(value2, serializer);
      }
    }
    if (sortObjectKeys && isObject(value2)) {
      const copy = {};
      Object.keys(value2).sort().forEach((key2) => {
        copy[key2] = value2[key2];
      });
      value2 = copy;
    }
    return value2;
  }
}
function genErr({ value, valueType, path, rootValueName, problematicValueName }) {
  const subjectName = getSubjectName({ path, rootValueName, problematicValueName });
  const messageCore = `cannot serialize ${subjectName} because it's a ${valueType}`;
  const err = new Error(`[@brillout/json-serializer](https://github.com/brillout/json-serializer) ${messageCore}.`);
  const pathString = getPathString(path, true);
  const errAddendum = {
    [stamp]: true,
    messageCore,
    value,
    path,
    pathString,
    subjectName
  };
  Object.assign(err, errAddendum);
  return err;
}
var stamp = "_isJsonSerializerError";
function isJsonSerializerError(thing) {
  return isObject(thing) && thing[stamp] === true;
}
function getSubjectName({ path, rootValueName, problematicValueName }) {
  const pathString = getPathString(path, !rootValueName);
  let subjectName;
  if (!pathString) {
    subjectName = rootValueName || problematicValueName || "value";
  } else {
    if (problematicValueName) {
      subjectName = problematicValueName + " at ";
    } else {
      subjectName = "";
    }
    subjectName = subjectName + (rootValueName || "") + pathString;
  }
  return subjectName;
}
function getPathString(path, canBeFirstKey) {
  const pathString = path.map((key, i) => {
    if (typeof key === "number") {
      return `[${key}]`;
    }
    if (i === 0 && canBeFirstKey && isKeyDotNotationCompatible(key)) {
      return key;
    }
    return getPropAccessNotation(key);
  }).join("");
  return pathString;
}
function getPropAccessNotation(key) {
  return typeof key === "string" && isKeyDotNotationCompatible(key) ? `.${key}` : `[${JSON.stringify(key)}]`;
}
function isKeyDotNotationCompatible(key) {
  return /^[a-z0-9\$_]+$/i.test(key);
}
export {
  isJsonSerializerError,
  stringify
};
//# sourceMappingURL=vike___@brillout_json-serializer_stringify.js.map
